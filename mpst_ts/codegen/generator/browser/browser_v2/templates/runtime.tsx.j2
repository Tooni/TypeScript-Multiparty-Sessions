// Runtime.tsx
import React from 'react';

import { State, SendState, ReceiveState, TerminalState, Roles } from './EFSM';
import { 
  Constructor, ReceiveHandler, 
  isSendState, isReceiveState, isTerminalState,
  SendComponentFactory, 
  DOMEvents, FunctionArguments, EventHandler
} from './Session';
{% for state in endpoint.efsm.states %}
import S{{ state.id }} from './S{{ state.id }}';
{%- endfor %}

type P = {
  endpoint: string,
  states: {
    {% for state in endpoint.efsm.states -%}
    S{{ state.id }}: Constructor<S{{ state.id }}>,
    {% endfor %}
  },
  waiting: JSX.Element
}

type S = {
  ws: WebSocket,
  elem: JSX.Element
}

// FIXME: relocate
type RoleToMessageQueue = { [Role in Roles]: any[] };
type RoleToHandlerQueue = { [Role in Roles]: ReceiveHandler[] };
interface MPSTMessage {
  role: Roles
  label: string
  payload: any[]
}

export default class {{ endpoint.role }} extends React.Component<P, S> {

  private messageQueue: RoleToMessageQueue
  private handlerQueue: RoleToHandlerQueue

  constructor(props: P) {
    super(props);

    // Set up WebSocket
    this.state = {
      ws: new WebSocket(props.endpoint),
      elem: props.waiting,
    };

    // Set up messageand handler queues
    this.messageQueue = {
      {% for role in endpoint.efsm.other_roles -%}
      [Roles.{{ role }}]: [],
      {%- endfor %}
    };
    this.handlerQueue = {
      {% for role in endpoint.efsm.other_roles -%}
      [Roles.{{ role }}]: [],
      {%- endfor %}
    };

    // Bind functions
    this.onReceiveInit = this.onReceiveInit.bind(this);
    this.onReceiveMessage = this.onReceiveMessage.bind(this);
    this.buildSendElement = this.buildSendElement.bind(this);
    this.registerReceiveHandler = this.registerReceiveHandler.bind(this);
  }

  componentDidMount() {
    this.state.ws.addEventListener('message', this.onReceiveInit);
    this.state.ws.addEventListener('open', () => this.state.ws.send(JSON.stringify({
      connect: '{{ endpoint.role }}'
    })));
  }

  private onReceiveInit(message: MessageEvent) {
    this.state.ws.removeEventListener('message', this.onReceiveInit);
    this.state.ws.addEventListener('message', this.onReceiveMessage);

    {% if endpoint.efsm.is_send_state(endpoint.efsm.initial_state) -%}
    this.advance(SendState.S{{ endpoint.efsm.initial_state }});
    {% elif endpoint.efsm.is_receive_state(endpoint.efsm.initial_state) -%}
    this.advance(ReceiveState.S{{ endpoint.efsm.initial_state }});
    {% else -%}
    this.advance(TerminalState.S{{ endpoint.efsm.initial_state }});
    {% endif %}
  }

  private advance(state: State) {
    if (isSendState(state)) {
      const View = this.props.states[state];
      this.setState({
        elem: <View factory={this.buildSendElement} />
      });
    } else if (isReceiveState(state)) {
      const View = this.props.states[state];
      this.setState({
        elem: <View register={this.registerReceiveHandler} />
      });
    } else if (isTerminalState(state)) {
      const View = this.props.states[state];
      this.setState({
        elem: <View />
      });
    }
  }

  private buildSendElement<T>(role: Roles, label: string, successor: State): SendComponentFactory<T> {
    return <K extends keyof DOMEvents> (eventLabel: K, handler: EventHandler<T, K>) => {
      const send = (payload: T) => this.sendMessage(role, label, payload, successor);

      return class extends React.Component {
        render() {
          const children = React.Children.map(this.props.children, child => (
            React.cloneElement(child as React.ReactElement<any>, {
              [eventLabel as string]: (event: FunctionArguments<DOMEvents[K]>) => {
                const result = handler(event);
                if (result instanceof Promise) {
                  result.then(send).catch(console.error);
                } else {
                  send(result);
                }
              }
            })
          ));
          return children;
        }
      }
    }
  }

  private sendMessage(role: Roles, label: string, payload: any, successor: State) {
    this.state.ws.send(JSON.stringify({ role, label, payload }));
    this.advance(successor);
  }

  private registerReceiveHandler(role: Roles, handle: ReceiveHandler) {
    const message = this.messageQueue[role].shift();
    if (message !== undefined) {
      // Message received already -- process.
      const continuation = handle(message);
      if (continuation instanceof Promise) {
        continuation.then(this.advance).catch(console.error);
      } else {
        this.advance(continuation);
      }
    } else {
      // No message received -- `queue' handler.
      this.handlerQueue[role].push(handle);
    }
  }

  private onReceiveMessage({ data }: MessageEvent) {
    const message = JSON.parse(data) as MPSTMessage;
    const handler = this.handlerQueue[message.role].shift();
    if (handler !== undefined) {
      // Handler registered -- process.
      const continuation = handler(data);
      if (continuation instanceof Promise) {
        continuation.then(this.advance).catch(console.error);
      } else {
        this.advance(continuation);
      }
    } else {
      // No handler registered -- `queue' message.
      this.messageQueue[message.role].push(message);
    }
  }

  render() {
    return this.state.elem;
  }

}