// Runtime.tsx
import React from 'react';

import * as Cancellation from './Cancellation';
import { State, SendState, ReceiveState, TerminalState, Roles } from './EFSM';
import { 
  Constructor, ReceiveHandler, 
  isSendState, isReceiveState, isTerminalState,
  SendComponentFactory, 
  DOMEvents, FunctionArguments, EventHandler
} from './Session';
{% for state in endpoint.efsm.states %}
import S{{ state.id }} from './S{{ state.id }}';
{%- endfor %}

type P = {
  endpoint: string,
  states: {
    {% for state in endpoint.efsm.states -%}
    S{{ state.id }}: Constructor<S{{ state.id }}>,
    {% endfor %}
  },
  waiting: JSX.Element,
  connectFailed: JSX.Element,
  cancellation: (role: '{{ endpoint.role }}' | Roles, reason?: any) => JSX.Element,
}

type S = {
  ws: WebSocket,
  elem: JSX.Element
}

// FIXME: relocate
type RoleToMessageQueue = { [Role in Roles]: any[] };
type RoleToHandlerQueue = { [Role in Roles]: ReceiveHandler[] };
interface MPSTMessage {
  role: Roles
  label: string
  payload: any[]
}

export default class {{ endpoint.role }} extends React.Component<P, S> {

  private messageQueue: RoleToMessageQueue
  private handlerQueue: RoleToHandlerQueue

  constructor(props: P) {
    super(props);

    // Set up WebSocket
    this.state = {
      ws: new WebSocket(props.endpoint),
      elem: props.waiting,
    };

    // Set up message and handler queues
    this.messageQueue = {
      {% for role in endpoint.efsm.other_roles -%}
      [Roles.{{ role }}]: [],
      {%- endfor %}
    };
    this.handlerQueue = {
      {% for role in endpoint.efsm.other_roles -%}
      [Roles.{{ role }}]: [],
      {%- endfor %}
    };

    // Bind functions
    this.onReceiveInit = this.onReceiveInit.bind(this);
    this.onCloseInit = this.onCloseInit.bind(this);
    this.onClose = this.onClose.bind(this);
    this.onReceiveMessage = this.onReceiveMessage.bind(this);
    this.buildSendElement = this.buildSendElement.bind(this);
    this.registerReceiveHandler = this.registerReceiveHandler.bind(this);
    this.cancel = this.cancel.bind(this);
    this.terminate = this.terminate.bind(this);
  }

  componentDidMount() {
    const { ws } = this.state;
    ws.onmessage = this.onReceiveInit;

    // Send connection message
    ws.onopen = () => {
      ws.send(JSON.stringify({
          connect: 'Client'
      }));
    };

    // Handle error
    ws.onerror = (event) => {
      console.log(event);
      this.setState({ elem: this.props.connectFailed });
    }

    ws.onclose = this.onCloseInit;
  }

  private onReceiveInit(message: MessageEvent) {
    const { ws } = this.state;
    ws.onmessage = this.onReceiveMessage;
    ws.onclose = this.onClose;

    {% if endpoint.efsm.is_send_state(endpoint.efsm.initial_state) -%}
    this.advance(SendState.S{{ endpoint.efsm.initial_state }});
    {% elif endpoint.efsm.is_receive_state(endpoint.efsm.initial_state) -%}
    this.advance(ReceiveState.S{{ endpoint.efsm.initial_state }});
    {% else -%}
    this.advance(TerminalState.S{{ endpoint.efsm.initial_state }});
    {% endif %}
  }

  private onCloseInit({ code, wasClean, reason }: CloseEvent) {
    if (!wasClean) {
      // Not closed properly
      this.setState({ elem: this.props.connectFailed });
      return;
    }

    switch (code) {
      case Cancellation.Receive.ROLE_OCCUPIED: {
        this.processCancellation('{{ endpoint.role }}', 'role occupied');
        return;
      }
      default: {
        // Unsupported code
        // FIXME: figure out which is server
        this.processCancellation('{{ endpoint.role }}', reason);
        return;
      }
    }
  }

  private onClose({ code, reason }: CloseEvent) {
    switch (code) {
      case Cancellation.Receive.SERVER_DISCONNECT: {
        // Server role disconnected
        // FIXME: figure out which is the server other_roles
        this.processCancellation('{{ endpoint.role }}', 'server disconnected');
        return;
      }
      case Cancellation.Receive.CLIENT_DISCONNECT: {
        // Other client disconnected
        // FIXME: load cancellation screen
        const { role, reason: description } = JSON.parse(reason);
        this.processCancellation(role, description);
        return;
      }
      case Cancellation.Receive.LOGICAL_ERROR: {
        // Logical error by some role
        // FIXME: load cancellation screen
        const { role, reason: description } = JSON.parse(reason);
        this.processCancellation(role, description);
        return;
      }
      default: {
        // Unsupported error code
        // FIXME: figure out which is the server other_roles
        this.processCancellation('{{ endpoint.role }}', reason);
        return;
      }
    }
  }

  private advance(state: State) {
    if (isSendState(state)) {
      const View = this.props.states[state];
      this.setState({
        elem: <View factory={this.buildSendElement} />
      });
    } else if (isReceiveState(state)) {
      const View = this.props.states[state];
      this.setState({
        elem: <View register={this.registerReceiveHandler} />
      });
    } else if (isTerminalState(state)) {
      const View = this.props.states[state];
      this.setState({
        elem: <View terminate={this.terminate} />
      });
    }
  }

  private buildSendElement<T>(role: Roles, label: string, successor: State): SendComponentFactory<T> {
    return <K extends keyof DOMEvents> (eventLabel: K, handler: EventHandler<T, K>) => {

      // Boolean flag since send(...) can be async;
      // must not be triggered twice.
      let used = false;

      const send = (payload: T) => this.sendMessage(role, label, payload, successor);
      const cancel = (error?: any) => this.cancel(error);

      return class extends React.Component {
        render() {
          const children = React.Children.map(this.props.children, child => (
            React.cloneElement(child as React.ReactElement<any>, {
              [eventLabel as string]: (event: FunctionArguments<DOMEvents[K]>) => {

                if (used) {
                  return;
                }

                used = true;

                try {
                  const result = handler(event);
                  if (result instanceof Promise) {
                    result.then(send).catch(cancel);
                  } else {
                    send(result);
                  }
                } catch (error) {
                  cancel(error);
                }

              }
            })
          ));
          return children;
        }
      }
    }
  }

  private sendMessage(role: Roles, label: string, payload: any, successor: State) {
    try {
      this.state.ws.send(JSON.stringify({ role, label, payload }));
      this.advance(successor);
    } catch (error) {
      this.cancel(error);
    }
  }

  private registerReceiveHandler(role: Roles, handle: ReceiveHandler) {
    const message = this.messageQueue[role].shift();
    if (message !== undefined) {
      // Message received already -- process.
      try {
        const continuation = handle(message);
        if (continuation instanceof Promise) {
          continuation.then(this.advance).catch(this.cancel);
        } else {
          this.advance(continuation);
        }
      } catch (error) {
        this.cancel(error);
      }
    } else {
      // No message received -- `queue' handler.
      this.handlerQueue[role].push(handle);
    }
  }

  private onReceiveMessage({ data }: MessageEvent) {
    const message = JSON.parse(data) as MPSTMessage;
    const handler = this.handlerQueue[message.role].shift();
    if (handler !== undefined) {
      // Handler registered -- process.
      try {
        const continuation = handler(data);
        if (continuation instanceof Promise) {
          continuation.then(this.advance).catch(this.cancel);
        } else {
          this.advance(continuation);
        }
      } catch (error) {
        this.cancel(error);
      }
    } else {
      // No handler registered -- `queue' message.
      this.messageQueue[message.role].push(message);
    }
  }

  private terminate() {
    this.state.ws.close(Cancellation.Emit.NORMAL);
  }

  private processCancellation(role: '{{ endpoint.role }}' | Roles, reason?: any) {

    // FIXME: the 'reason' parameter should be of type any
    // so the developer can customise their handler behaviour.

    if (reason !== undefined) {
      this.setState({
        elem: this.props.cancellation(role, String(reason)),
      });
    } else {
      this.setState({
        elem: this.props.cancellation(role),
      });
    }
  }

  private cancel(error?: any) {
    // Emit cancellation
    this.state.ws.close(Cancellation.Emit.LOGICAL_ERROR, JSON.stringify({
      role: '{{ endpoint.role }}',
      reason: error !== undefined ? String(error) : error,
    }));

    // Process cancellation
    this.processCancellation('{{ endpoint.role }}', error);
  }

  render() {
    return this.state.elem;
  }

}