{% for type in endpoint.types -%}
import { {{ type.external ~ ((' as ' ~ type.alias) if type.external != type.alias else '') }} } from "{{ type.path }}";
{% endfor %}

type MaybePromise<T> = T | Promise<T>;
type FromJust<T> = T extends MaybePromise<infer R> ? R : unknown;

// ==============
// Protocol roles
// ==============

export enum Roles {
  {% for role in endpoint.efsm.other_roles -%}
  {{ role }} = "{{ role }}",
  {%- endfor %}
};

// ==============
// Message labels
// ==============

export namespace Labels {
  {% for state in endpoint.efsm.receive_states -%}
  export enum S{{ state.id }} 
  {
    {% for label in state.labels -%}
    {{ label }} = "{{ label }}",
    {%- endfor %}
  };
  {% endfor %}
  {% for state in endpoint.efsm.send_states -%}
  export enum S{{ state.id }} 
  {
    {% for label in state.labels -%}
    {{ label }} = "{{ label }}",
    {%- endfor %}
  };
  {% endfor %}
};

// =======
// Message
// =======
namespace Message {
{% for state in endpoint.efsm.nonterminal_states %}
  {% for action in state.actions -%}
  export type S{{ state ~ action.label }} = {
    label: Labels.S{{ state }}.{{ action.label }},
    payload: [{{ action.payloads|join(', ') }}],
  };
  {% endfor %}
  export type S{{ state }} = {% for action in state.actions -%}
  | S{{ state ~ action.label }}{% endfor %};
{% endfor %}
};

// ================
// Message handlers
// ================

export namespace Handler {
  {% for state in endpoint.efsm.send_states -%}
  export type S{{ state }} =
    MaybePromise<{% for action in state.actions -%}
    | [Labels.S{{ state }}.{{ action.label }}, Message.S{{ state ~ action.label }}['payload'], Implementation.S{{ action.succ }}]
    {%- endfor %}>;
  {% endfor %}
  {% for state in endpoint.efsm.receive_states -%}
  export type S{{ state }} = {
    {% for action in state.actions -%}
    [Labels.S{{ state }}.{{ action.label }}]: (...payload: Message.S{{ state ~ action.label }}['payload']) => MaybePromise<Implementation.S{{ action.succ }}>,
    {% endfor %}
  }
  {% endfor %}
  {% if endpoint.efsm.has_terminal_state() -%}
  export type S{{ endpoint.efsm.terminal_state }} = 'Terminate';
  {% endif -%}
};

// =================================
// "Implementation"
// := wrapper around message handler
// =================================

export namespace Implementation {
  abstract class Send {
    type: 'Send' = 'Send';
    abstract performSend(
      next: EfsmTransitionHandler,
      sendMessage: (role: Roles, label: string, payload: any[]) => void
    ): void;
  }

  abstract class Receive {
    type: 'Receive' = 'Receive';
    abstract prepareReceive(
      next: EfsmTransitionHandler,
      register: (from: Roles, messageHandler: MessageHandler) => void
    ): void;
  }

  abstract class Terminal {
    type: 'Terminal' = 'Terminal';
  }

  export type Type = Send | Receive | Terminal;

  {% for state in endpoint.efsm.states -%}
  {% if endpoint.efsm.is_send_state(state) -%}
  export class S{{ state }} extends Send {

    constructor(private handler: Handler.S{{ state }}) {
      super();
    }

    performSend(
      next: EfsmTransitionHandler,
      sendMessage: (role: Roles, label: string, payload: any[]) => void
    ) {
      const thunk = ([label, payload, successor]: FromJust<Handler.S{{ state }}>) => {
        sendMessage(Roles.{{ state.role }}, label, payload);
        return next(successor);
      }
      if (this.handler instanceof Promise) {
        // Asynchronous implementation -- wait for completion
        this.handler.then(thunk).catch(console.error);
      } else {
        thunk(this.handler);
      }
    }

  }
  {% elif endpoint.efsm.is_receive_state(state) -%}
  export class S{{ state }} extends Receive {

    constructor(private handler: Handler.S{{ state}}) {
      super();
    }

    prepareReceive(
      next: EfsmTransitionHandler, 
      register: (from: Roles, messageHandler: MessageHandler) => void
    ) {
      const messageHandler = (message: any) => {
        const parsedMessage = JSON.parse(message) as Message.S{{ state.id }};
        switch (parsedMessage.label) {
          {% for action in state.actions -%}
          case Labels.S{{ state }}.{{ action.label }}: {
            const successor = this.handler[parsedMessage.label](...parsedMessage.payload);
            if (successor instanceof Promise) {
              successor.then(next).catch(console.error);
            } else {
              next(successor);
            }
            return;
          }
          {% endfor %}
          // default: {
          //   throw new Error(`Unexpected receive: ${parsedMessage.label}`);
          // }
        }
      }

      register(Roles.{{ state.role }}, messageHandler);
    }

  }
  {% else -%}
  export class S{{ state }} extends Terminal {

    constructor(private handler: Handler.S{{ state }}) {
      super();
    }

  }
  {% endif -%}
  {%- endfor %}
}

// =============
// Runtime types
// =============

export type EfsmTransitionHandler = (implementation: Implementation.Type) => void
export type MessageHandler = (message: any) => void