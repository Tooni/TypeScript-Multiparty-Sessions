// ==============
// Protocol roles
// ==============

export enum Roles {
  {% for role in endpoint.efsm.other_roles -%}
  {{ role }} = "{{ role }}",
  {%- endfor %}
};

// ==============
// Message labels
// ==============

export namespace Labels {
  {% for state in endpoint.efsm.receive_states -%}
  export enum S{{ state.id }} 
  {
    {% for label in state.labels -%}
    {{ label }} = "{{ label }}",
    {%- endfor %}
  };
  {%- endfor %}
  {% for state in endpoint.efsm.send_states -%}
  export enum S{{ state.id }} 
  {
    {% for label in state.labels -%}
    {{ label }} = "{{ label }}",
    {%- endfor %}
  };
  {%- endfor %}
};

// =======
// Message
// =======
namespace Message {
{% for state in endpoint.efsm.nonterminal_states -%}
  {% for action in state.actions -%}
  export type S{{ state ~ action.label }} = {
    label: Labels.S{{ state }}.{{ action.label }},
    payload: [{{ action.payloads|join(', ') }}],
  };
  {% endfor %}
  export type S{{ state }} = {% for action in state.actions -%}
  | S{{ state ~ action.label }}{% endfor %};
{% endfor %}
};

// ================
// Message handlers
// ================

export namespace Handler {
  {% for state in endpoint.efsm.send_states -%}
  export type S{{ state }} =
    {% for action in state.actions -%}
    | [Labels.S{{ state }}.{{ action.label }}, Message.S{{ state ~ action.label }}['payload'], Implementation.S{{ action.succ }}]
    {%- endfor %};
  {% endfor %}
  {% for state in endpoint.efsm.receive_states -%}
  export type S{{ state }} = {
    {% for action in state.actions -%}
    [Labels.S{{ state }}.{{ action.label }}]: (...payload: Message.S{{ state ~ action.label }}['payload']) => Implementation.S{{ action.succ }},
    {% endfor %}
  }
  {% endfor %}
  {% if endpoint.efsm.has_terminal_state() -%}
  export type S{{ endpoint.efsm.terminal_state }} = 'Terminate';
  {% endif -%}
};

// =================================
// "Implementation"
// := wrapper around message handler
// =================================

export namespace Implementation {
  abstract class Send {
    type: 'Send' = 'Send';
    abstract performSend(
      next: EfsmTransitionHandler,
      sendMessage: (role: Roles, label: string, payload: any[]) => void
    ): void;
  }

  abstract class Receive {
    type: 'Receive' = 'Receive';
    abstract prepareReceive(
      next: EfsmTransitionHandler,
      register: (messageHandler: MessageHandler) => void
    ): void;
  }

  abstract class Terminal {
    type: 'Terminal' = 'Terminal';
  }

  export type Type = Send | Receive | Terminal;

  {% for state in endpoint.efsm.states -%}
  {% if endpoint.efsm.is_send_state(state) -%}
  export class S{{ state }} extends Send {

    constructor(private handler: Handler.S{{ state }}) {
      super();
    }

    performSend(
      next: EfsmTransitionHandler,
      sendMessage: (role: Roles, label: string, payload: any[]) => void
    ) {
      const [label, payload, successor] = this.handler;
      sendMessage(Roles.{{ state.role }}, label, payload);
      return next(successor);
    }

  }
  {% elif endpoint.efsm.is_receive_state(state) -%}
  export class S{{ state }} extends Receive {

    constructor(private handler: Handler.S{{ state}}) {
      super();
    }

    prepareReceive(
      next: EfsmTransitionHandler, 
      register: (messageHandler: MessageHandler) => void
    ) {
      const messageHandler = (message: any) => {
        const parsedMessage = JSON.parse(message) as Message.S{{ state.id }};
        switch (parsedMessage.label) {
          {% for action in state.actions -%}
          case Labels.S{{ state }}.{{ action.label }}: {
            const successor = this.handler[parsedMessage.label](...parsedMessage.payload);
            return next(successor);
          }
          {% endfor %}
        }
      }

      register(messageHandler);
    }

  }
  {% else -%}
  export class S{{ state }} extends Terminal {

    constructor(private handler: Handler.S{{ state }}) {
      super();
    }

  }
  {% endif -%}
  {%- endfor %}
}

// =============
// Runtime types
// =============

export type EfsmTransitionHandler = (implementation: Implementation.Type) => void
export type MessageHandler = (message: any) => void