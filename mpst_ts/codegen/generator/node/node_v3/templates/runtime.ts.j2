import WebSocket from 'ws';

import { Cancellation, Roles, Implementation, MessageHandler } from './EFSM';

/**
 * Helper types
 *
 * TODO: decouple from this file.
 */
type Partial<T> = { [K in keyof T]: T[K] | undefined };
type RoleToSocket = { [Role in Roles]: WebSocket };
type RoleToMessageQueue = { [Role in Roles]: any[] };
type RoleToHandlerQueue = { [Role in Roles]: MessageHandler[] };

interface MPSTMessage {
  role: Roles | '{{ endpoint.role }}'
  label: string
  payload: any[]
}

interface WebSocketMessage {
  data: any
  type: string
  target: WebSocket
}

interface JoinMessage {
  connect: Roles
}

/**
 * Joining
 */
export class {{ endpoint.role }}
{

  private wss: WebSocket.Server
  private waiting: Set<Roles>
  private roleToSocket: Partial<RoleToSocket>
  private cancellation: (role: '{{ endpoint.role }}' | Roles, reason?: string) => void

  constructor(wss: WebSocket.Server,
              initialState: Implementation.S{{ endpoint.efsm.initial_state.id }},
              cancellation: (role: '{{ endpoint.role }}' | Roles, reason?: string) => void)
  {
    this.wss = wss;
    this.waiting = new Set<Roles>([{% for role in endpoint.efsm.other_roles %}Roles.{{ role ~ (',' if not loop.last else '') }}{% endfor %}]);
    this.cancellation = cancellation;

    this.roleToSocket = {
      {% for role in endpoint.efsm.other_roles -%}
      [Roles.{{ role }}]: undefined,
      {%- endfor %}
    };

    const socketToRole = new Map<WebSocket, Roles>();

    const onClose = (event: WebSocket.CloseEvent) => {
      const { target: socket } = event;
      socket.removeAllListeners();

      const role = socketToRole.get(socket);
      if (role !== undefined) {
        this.waiting.add(role);
      }
    }

    const onSubscribe = (event: WebSocketMessage) => {
      const { data, target: socket } = event;
      const { connect: role } = JSON.parse(data) as JoinMessage;
      if (!this.waiting.has(role)) {
        // Role already occupied

        socket.removeAllListeners();

        socket.close(Cancellation.Emit.ROLE_OCCUPIED);

        return;
      }

      this.roleToSocket[role] = socket;

      socketToRole.set(socket, role);
      
      this.waiting.delete(role);
      
      socket.removeAllListeners();

      if (this.waiting.size === 0) {
        this.wss.removeListener('connection', onConnection);
        for (const socket of Object.values(this.roleToSocket)) {
          socket?.send(JSON.stringify({
            connected: true
          }));
        }

        // Execute protocol
        new _{{ endpoint.role }}(this.wss, this.roleToSocket as RoleToSocket, cancellation, initialState);
      }
    }

    const onConnection = (ws: WebSocket) => {
      ws.onmessage = onSubscribe;
      ws.onclose = onClose;
    };
    this.wss.addListener('connection', onConnection);
  }

}

class _{{ endpoint.role }} {

  private wss: WebSocket.Server
  private roleToSocket: RoleToSocket
  private cancellation: (role: '{{ endpoint.role }}' | Roles, reason?: string) => void
  
  private initialState: Implementation.S{{ endpoint.efsm.initial_state.id }}
  private messageQueue: RoleToMessageQueue
  private handlerQueue: RoleToHandlerQueue

  private activeRoles: Set<Roles>

  constructor(wss: WebSocket.Server,
              roleToSocket: RoleToSocket,
              cancellation: (role: '{{ endpoint.role }}' | Roles, reason?: string) => void,
              initialState: Implementation.S{{ endpoint.efsm.initial_state.id }}) {
    this.wss = wss;
    this.roleToSocket = roleToSocket;
    this.cancellation = cancellation;
    this.initialState = initialState;
    this.activeRoles = new Set<Roles>([{% for role in endpoint.efsm.other_roles %}Roles.{{ role ~ (',' if not loop.last else '') }}{% endfor %}]);

    // Bind instance methods.
    this.next = this.next.bind(this);
    this.receive = this.receive.bind(this);
    this.registerMessageHandler = this.registerMessageHandler.bind(this);
    this.send = this.send.bind(this);
    this.cancel = this.cancel.bind(this);
    
    // Bind socket message handler.
    Object.values(Roles).forEach(role => {
      const socket = this.roleToSocket[role];

      socket.onmessage = this.receive(role);

      socket.onclose = ({ code, reason }) => {
        switch (code) {
          case Cancellation.Receive.NORMAL:
            // Normal cancellation

            socket.removeAllListeners();

            this.activeRoles.delete(role);
            if (this.activeRoles.size === 0) {
              new {{ endpoint.role }}(this.wss, initialState, this.cancellation);
            }

            return;
          case Cancellation.Receive.CLIENT_BROWSER_CLOSED:
            // Client closed their browser
            this.propagateCancellation(role, 'browser disconnected');
            return;
          case Cancellation.Receive.LOGICAL_ERROR:
            // Client has logical error
          default:
            // Unsupported code
            this.propagateCancellation(role, reason);
            return;
        }
      }
    })
    
    // Initialise queues for receiving.
    this.messageQueue = {
      {% for role in endpoint.efsm.other_roles -%}
      [Roles.{{ role }}]: [],
      {%- endfor %}
    };
    this.handlerQueue = {
      {% for role in endpoint.efsm.other_roles -%}
      [Roles.{{ role }}]: [],
      {%- endfor %}
    };
    
    // Initialise state machine.
    this.next(initialState);
  }

  // =====================
  // State machine methods
  // =====================
  next(implementation: Implementation.Type) {
    try {
      switch (implementation.type) {
        case 'Send': {
          return implementation.performSend(this.next, this.cancel, this.send);
        }
        case 'Receive': {
          return implementation.prepareReceive(this.next, this.cancel, this.registerMessageHandler);
        }
        case 'Terminal': {
          return;
        }
      }
    } catch (error) {
      this.cancel(error);
    }
  }

  // ===============
  // Channel methods
  // ===============

  send(to: Roles, label: string, payload: any[], from: string = '{{ endpoint.role }}') {
    this.roleToSocket[to].send(JSON.stringify({ role: from, label, payload }));
  }

  receive(from: Roles) {
    return ({ data }: WebSocketMessage) => {
      const { role, label, payload } = JSON.parse(data) as MPSTMessage;
      if (role !== '{{ endpoint.role }}') {
        // Route message
        this.send(role, label, payload, from);
      } else {
        const handler = this.handlerQueue[from].shift();
        if (handler !== undefined) {
          handler(data);
        } else {
          this.messageQueue[from].push(data);
        }
      }
    }
  }

  registerMessageHandler(from: Roles, messageHandler: MessageHandler) {
    const message = this.messageQueue[from].shift();
    if (message !== undefined) {
      messageHandler(message);
    } else {
      this.handlerQueue[from].push(messageHandler);
    }
  }

  // FIXME: remove method
  // terminate() {
  //   Object.values(this.roleToSocket).forEach(socket => socket.close());
  //   new {{ endpoint.role }}(this.wss, this.initialState);
  // }

  /**
    * Propagate explicit cancellation to other roles.
    * 
    * @param cancelledRole 
    */
  propagateCancellation(cancelledRole: Roles, reason?: string) {
    this.cancellation(cancelledRole, reason);

    Object.entries(this.roleToSocket)
      .filter(([role, _]) => role !== cancelledRole)
      .forEach(([_, socket]) => {
        socket.removeAllListeners();
        socket.close(Cancellation.Emit.LOGICAL_ERROR, JSON.stringify({ role: cancelledRole, reason }))
      });
    
    new {{ endpoint.role }}(this.wss, this.initialState, this.cancellation);
  }

  cancel(reason?: string) {
    this.cancellation('{{ endpoint.role }}', reason);

    Object.values(this.roleToSocket)
      .forEach(socket => {
        socket.removeAllListeners();
        socket.close(Cancellation.Emit.LOGICAL_ERROR, JSON.stringify({ role: '{{ endpoint.role }}', reason }))
      });

    new {{ endpoint.role }}(this.wss, this.initialState, this.cancellation);
  }
}
